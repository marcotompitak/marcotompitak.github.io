<!DOCTYPE html>
<html>
  <head>
    
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="shortcut icon" href="/static/img/favicon.ico" />
        <title>Matched Filtering - Marco Tompitak</title>
        <meta name="author" content="Marco Tompitak" />
        <meta name="description" content="Matched Filtering" />
        <meta name="keywords" content="Matched Filtering, Marco Tompitak, signal-processing didactic" />

        <meta content="0" property="fb:app_id">
        <meta content="Marco Tompitak" property="og:site_name">
        
          <meta content="Matched Filtering" property="og:title">
        
        
          <meta content="article" property="og:type">
        
        
          <meta content="My GitHub Page" property="og:description">
        
        
          <meta content="http://localhost:4000/matched-filter/" property="og:url">
        
        
          <meta content="2017-07-20T02:00:00+02:00" property="article:published_time">
          <meta content="http://localhost:4000/about/" property="article:author">
        
        
          <meta content="http://localhost:4000/static/img/logo-high-resolution.png" property="og:image">
        
        
          
          <meta content="signal-processing didactic" property="article:section">
          
        
        
        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@\#">
        <meta name="twitter:creator" content="@\#">
        
          <meta name="twitter:title" content="Matched Filtering">
        
        
          <meta name="twitter:url" content="http://localhost:4000/matched-filter/">
        
        
          <meta name="twitter:description" content="My GitHub Page">
        
        

      <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">
      <script type="text/javascript">window.baseurl = 'http://localhost:4000';</script>
      
        <!-- Custom Fonts -->
        <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,400,500,700" type="text/css">

        <!-- FontAwesome icons -->
        <link rel="stylesheet" href="https://use.fontawesome.com/74dfc6cf47.css">

        <!-- Core BootStrap CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <!-- Material Design CSS -->
        <link rel="stylesheet" href="/static/css/bootstrap-material-design.min.css">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/static/css/syntax.css">

        <!-- Custom CSS -->        
        <link rel="stylesheet" href="/static/css/thickbox.css">
        <link rel="stylesheet" href="/static/css/main.css">
        <link rel="stylesheet" href="/static/css/projects.css">

        <script type="text/javascript">
          //loadingImage is relative to project dir
          var tb_pathToImage = "/static/img/loadingAnimation.gif";
        </script>

  </head>

  <body class="home overflow-hidden">
    <div class="header-panel shadow-z-2">
      <div class="container">
        <div class="row">
          <div class="col-md-3 col-sm-4 col-xs-12">
            <div class="row-picture">
              <img id="about" class="logo-img" src="/static/img/avatar.svg" height="75px" width="75px">
            </div>
            <div class="row-details">
              <h4 class="list-group-item-heading">Marco Tompitak</h4>
              <p class="list-group-item-text">Biophysicist</p>
              <div class="social-icons">
	
        <a class="icon" target="_blank" href="https://github.com/marcotompitak"><i class="fa fa-github"></i></a>
    
        <a class="icon" target="_blank" href="https://www.linkedin.com/in/marcotompitak/"><i class="fa fa-linkedin"></i></a>
    
        <a class="icon" target="_blank" href="https://stackexchange.com/users/2808839/marco-tompitak"><i class="fa fa-stack-exchange"></i></a>
    
        <a class="icon" target="_blank" href="http://www.rapiddiffusion.com/"><i class="fa fa-pencil-square-o"></i></a>
    
</div>

            </div>
            <div class="navbar-header pull-right">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <i class="fa fa-2x fa-bars"></i>
              </button>
            </div>
          </div>
          <div class="col-md-9 col-sm-8 col-xs-12">
          <div class="row">
            <h2 class="blog-title-pro ">Matched Filtering</h2>
            
            </div>
            <p class="info">
              
                <span class="time">20 Jul 2017</span>
              
              
                <span class="categories">
                  &raquo; 
                  
                    <a href="/category/signal-processing didactic">signal-processing didactic</a>
                    
                  
                </span>
              
            </p>
          </div>
        </div>
      </div>
    </div>

    <div class="container main outer">
      <div class="row">
        <div class="col-md-3 col-xs-12">
              <nav class="menu">
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="list-separator nav navbar-nav well well-primary page">

	
	
	
	
	
	
    
	
	<li class="col-lg-12 col-md-12 col-sm-4 col-xs-12  matched-filter"><a href="/" target="_self"><i class="fa fa-home"></i> Home</a></li>

	
	
	
	
	
	
    
	
	<li class="col-lg-12 col-md-12 col-sm-4 col-xs-12  matched-filter"><a href="/about/" target="_self"><i class="fa fa-user"></i> About</a></li>

	
	
	
	
	
	
    
	
	<li class="col-lg-12 col-md-12 col-sm-4 col-xs-12  matched-filter"><a href="/projects" target="_self"><i class="fa fa-desktop"></i> Projects</a></li>

	
	
	
	
	
	
    
	
	<li class="col-lg-12 col-md-12 col-sm-4 col-xs-12  matched-filter"><a href="/publications" target="_self"><i class="fa fa-file-text-o"></i> Publications</a></li>

	
	
	
	
	
	
    
	
	<li class="col-lg-12 col-md-12 col-sm-4 col-xs-12  matched-filter"><a href="https://github.com/marcotompitak" target="_self"><i class="fa fa-github"></i> Github</a></li>

</ul>

    </div>
    </nav>

        </div>
        <div class="col-md-9 col-xs-12 full">
          <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<div class="well" style="text-align:justify">
    
    <div>
    	<h1 id="searching-for-signals-using-matched-filters">Searching for Signals using Matched Filters</h1>

<p><em>(This is a static version of an iPython notebook. The actual notebooks can be found on <a href="https://github.com/marcotompitak/gravitational-waves">GitHub</a>.)</em></p>

<p>In this (two-part) notebook we will go through the basics of matched filters and see how powerful this method can be. In the <a href="/pe-pymc/">second part of this session</a> we’ll look at using <code class="highlighter-rouge">pymc</code> to apply statistical methods.</p>

<p>The basic idea is as follows: if a signal is buried in noise that is much stronger, you can still detect that signal, if you know what you are looking for.</p>

<p>If you’re interested in the mathematics behind the methods we will be using, you can have a look on <a href="https://en.wikipedia.org/wiki/Matched_filter">Wikipedia</a>; but with this notebook you will hopefully get the ideas clear heuristically by getting your hands dirty yourself.</p>

<h3 id="chirp-signals">Chirp signals</h3>

<p>Let’s first define a function that will generate the signals we are interested in. This function, <code class="highlighter-rouge">chirp</code>, mimics the shape of gravitational wave signals sent out by inspiraling binary star systems. It is an enormous simplification, as the actual shapes of these signals are <a href="https://arxiv.org/pdf/0907.0700v1.pdf">far too complicated</a> for our purposes.</p>

<p>We just take a simple sinusoidal signal, with some alterations. The basic parameters of the signal are an overal <code class="highlighter-rouge">offset</code>, a constant background term, the amplitude <code class="highlighter-rouge">A</code> of the oscillations, and their frequency <code class="highlighter-rouge">f</code>.</p>

<p>The main feature of these gravitational wave signals is that, as the two stars spiral towards each other and eventually collide, both the frequency and the amplitude of the signal increase, much like the chirp of a bird. We mimic this by adding two more parameters, <code class="highlighter-rouge">dA</code> and <code class="highlighter-rouge">df</code>, that linearly increase the amplitude and the frequency in time.</p>

<p>Finally, we add a parameter <code class="highlighter-rouge">tc</code> which encodes the <em>time of coalescence</em>, the moment in time when the two stars of the binary system collide. At this point the oscillatory behavior of the signal is terminated and only the background term remains.</p>

<p>All of this put together yields the following function:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pymc</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c"># For reproducibility</span>


<span class="k">def</span> <span class="nf">chirp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dA</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
    <span class="s">"""
    Generate a chirp signal.
    
    Arguments:
    t      -- array-like containing the times at which to evaluate the signal.
    tc     -- time of coalescence, after which the signal is terminated; for times beyond tc the signal is set to the constant background.
    offset -- constant background term
    A      -- initial signal amplitude at t=0
    dA     -- linear coefficient describing the increase of the amplitude with time
    f      -- initial signal frequency at t=0
    df     -- linear coefficient describing the increase of the frequency with time
    """</span>
    <span class="n">chirp</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">dA</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="n">df</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">chirp</span><span class="p">[</span><span class="n">t</span><span class="o">&gt;</span><span class="n">tc</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
    <span class="k">return</span> <span class="n">chirp</span>
</code></pre>
</div>

<p>So what does such a signal look like? Let’s choose some values for the parameters and have a look at a plot.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Injected values for our artificial signal</span>
<span class="n">tc_true</span> <span class="o">=</span> <span class="mi">75</span>
<span class="n">offset_true</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">A_true</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">dA_true</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">f_true</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">df_true</span> <span class="o">=</span> <span class="mf">0.01</span>

<span class="c"># Noise strength</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mi">250</span>

<span class="c"># Our time points</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">10001</span><span class="p">)</span>

<span class="c"># Our injection signal</span>
<span class="n">y_true</span> <span class="o">=</span> <span class="n">chirp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tc_true</span><span class="p">,</span> <span class="n">offset_true</span><span class="p">,</span> <span class="n">A_true</span><span class="p">,</span> <span class="n">dA_true</span><span class="p">,</span> <span class="n">f_true</span><span class="p">,</span> <span class="n">df_true</span><span class="p">)</span>

<span class="c"># Let's have a look at our signal!</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">y_true</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre>
</div>

<p><img src="/pages/MatchedFiltering_files/MatchedFiltering_4_0.png" alt="png" /></p>

<p>As you can see, the signal oscillates faster and faster as well as louder and louder, until at <code class="highlighter-rouge">t = tc</code> the oscillations collapse.</p>

<p>Now we want to simulate the very heavy noise that we have to deal with in gravitational wave detectors. Let’s generate some gaussian-distributed noise and inject our signal into it.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># We add some uninteresting stretches of data before and after the signal</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">offset_true</span><span class="p">,</span><span class="mi">2100</span><span class="p">),</span><span class="n">y_true</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">offset_true</span><span class="p">,</span><span class="mi">2900</span><span class="p">)))</span>

<span class="c"># The noise is normally distributed with standard deviation sigma.</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
</code></pre>
</div>

<p>Here is what the resulting data looks like when we inject our signal into the noise:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">signal</span><span class="o">+</span><span class="n">noise</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre>
</div>

<p><img src="/pages/MatchedFiltering_files/MatchedFiltering_8_0.png" alt="png" /></p>

<p>Can you see the signal in there? I didn’t think so. The noise we generated is more than an order of magnitude stronger than the signal, which is completely buried. If you didn’t know there was a signal to be found, you would probably think that is just noise.</p>

<p>But the signal is really in there; it’s just very small:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">signal</span><span class="o">+</span><span class="n">noise</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'r'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre>
</div>

<p><img src="/pages/MatchedFiltering_files/MatchedFiltering_10_0.png" alt="png" /></p>

<p>So how could we ever hope to find that signal? Definitely not by eye. Luckily we are not entirely clueless as to what signals we might find in the output of a gravitational wave detector. Inspiraling binary star systems are among the most promising sources of gravitational waves, and we may well expect to find chirp signals. So why don’t we do just that? Let’s see what we can do if we know what signal to expect.</p>

<h3 id="the-matched-filter">The Matched Filter</h3>

<p>In its simplest form, a matched filter is a signal processing method that tries to determine where a signal is in the data. It presupposes that</p>

<p>1) you know that there is a signal in the data; and
2) you know the shape of the signal exactly.</p>

<p>These are very stringent requirements for most data analysts, and we will loosen them considerably, but even in this basic form it has its applications. For instance in radar and sonar systems, where a known signal is sent out and expected to bounce off of objects and return to the source in more or less the same shape, it’s a useful tool.</p>

<p>Mathematically, the matched filter works as follows. Take a noisy time series $d(t)$, in which you know there is some signal $h(t)$ to be found,</p>

<script type="math/tex; mode=display">d(t) = n(t) + h(t-t_0),</script>

<p>i.e. the data consists of random noise plus some signal starting at time $t_0$. We now take the signal we expect (the ‘template’) and slide it along your data, seeing where it fits best. We do this by multiplying the data and the template at each time point:</p>

<script type="math/tex; mode=display">y = \sum_n d(t_n) h(t_n - t_0)</script>

<p>Now, if we have chosen $t_0$ incorrectly, we are just multiplying our template with random values,</p>

<script type="math/tex; mode=display">y = \sum_n n(t_n) h(t_n - t_0)</script>

<p>making some parts of the sum positive, some negative, and the whole thing should average out to zero. However, if we have aligned our template with the actual signal in the data, we get</p>

<script type="math/tex; mode=display">y = \sum_n n(t_n) h(t_n - t_0) + \sum_n h(t_n - t_0) h(t_n - t_0).</script>

<p>The first part will still be zero, on average, but the second term is a sum of squares and should yield a strong positive number, indicating that we have found the signal.</p>

<p>If we just do the above for every possible offset $t_0$, $y(t_0)$ should have a maximum at the point in time where the actual signal is.</p>

<p>So let’s see if this can help us detect our gravitational wave signal.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Applying the filter is just calculating a convolution</span>
<span class="n">filtered</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">y_true</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">signal</span><span class="o">+</span><span class="n">noise</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'valid'</span><span class="p">)</span>

<span class="c"># And then we want to know where the maximum value of this convolution is</span>
<span class="n">pos</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">filtered</span><span class="p">)</span>

<span class="c"># Let's plot the result</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="mf">1.1</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">filtered</span><span class="p">),</span> <span class="mf">1.1</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">filtered</span><span class="p">)])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s">'darkgreen'</span><span class="p">)</span>

<span class="c"># And have an arrow point at the maximum</span>
<span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="mf">1.1</span><span class="o">*</span><span class="nb">max</span><span class="p">(</span><span class="n">filtered</span><span class="p">)),</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">filtered</span><span class="p">)),</span>
    <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s">"-&gt;"</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s">'darkred'</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre>
</div>

<p><img src="/pages/MatchedFiltering_files/MatchedFiltering_12_0.png" alt="png" /></p>

<p>We see that the maximum lies at an offset of 2100 samples, which is exactly where we placed our signal! So, even such a tiny signal, buried in noise that is much, much stronger, can still be found with this method.</p>

<h3 id="exercise-1">Exercise 1</h3>
<ol>
  <li>As you see, in this case the ‘bad’ values of the filtered signal are not evenly distributed around zero. Can you explain why? Is it important?</li>
  <li>Can you think of any other method for finding the signal in the data if you know what the signal looks like? Does it work as well as the matched filter?</li>
</ol>

<h1 id="parameter-estimation-with-template-banks">Parameter estimation with template banks</h1>

<p>Of course, in general we are not going to have the luxury of knowing exactly what our signal looks like. It may depend on any number of parameters, like our chirp signal. But that doesn’t need to stop us from finding it!</p>

<p>Let’s assume that we at least know a reasonable functional form for the signals we are looking for, so that we can write a function like <code class="highlighter-rouge">chirp</code>. For gravitational waves this can be done for certain classes of signals, such as the binary star systems we’ve talked about. Einstein’s theory of relativity in principle predicts what the signals should look like (hard to calculate though they may be.)</p>

<p>If we have that, then we can build a template bank: for matched filtering we need a template; if we don’t know exactly what the template should look like, let’s just try all of them!</p>

<p>Above, we were essentially already doing parameter estimation: we were trying to find out at which time the signal starts. To do so we found that there is a quantity we can maximize. Extending the problem to other parameters is no different: just try different values of your parameters and see which one yields the biggest value for the matched filter!</p>

<h3 id="matched-filter-as-maximum-likelihood-estimator">Matched filter as maximum likelihood estimator</h3>

<p>Before we actually do that, though, we are going to change up the mathematical language we use a little. The matched filter as performed above using convolution is nice for demonstration purposes, but we’ll now look at the matched filter as a way of maximizing the <em>likelihood</em> of the parameters to be estimated. This is not entirely equivalent to what we did above, but the idea is the same.</p>

<p>The <a href="https://en.wikipedia.org/wiki/Likelihood_function">likelihood</a> tells us the probability of the observed data if we assume certain values for the parameters. For example, suppose we have Gaussian noise with variance $\sigma^2$, possibly contianing a signal, and a template function $h(\theta)$ where $\theta$ is a set of parameters. If we believe those parameters, then we believe that the noise looks like</p>

<script type="math/tex; mode=display">n(t, \theta) = d(t) - h(t, \theta).</script>

<p>But we know that the noise should be random, so if it does not look like it is properly distributed according to a gaussian distribution, we probably chose the wrong parameters. To quantify that idea, the likelihood of the parameters can be calculated by</p>

<script type="math/tex; mode=display">L(\theta) = P(n(t, \theta)) = \prod_{i} e^{-n^2(t_i)/\sigma^2}.</script>

<p>The last part is just the probability of the noise realization, given that we know its Gaussian distribution. The added benefit of this method is that we actually get probabilities distributions for the parameters we want to estimate.</p>

<h3 id="log-likelihood-and-log-odds-ratio">Log-likelihood and (log) Odds ratio</h3>

<p>It is usually most convenient to work with the logarithm of the likelihood. We now define functions to calculate this log-likelihood, as well as the (log of the) Odds ratio, which is a ratio between likelihoods of two different signals. In the following, we will compare the likelihoods of our signals to that of a zero-signal, i.e. the assumption that there is no signal in the data. This makes the numbers more meaningful:</p>

<ul>
  <li>Positive odds ratio means the template fits better than assuming no signal is present;</li>
  <li>Negative odds ratio means the template fits worse, meaning the parameters are probably very wrong.</li>
</ul>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Calculating the logarithmic likelihood is easier as it is just a sum, rather than a product</span>
<span class="k">def</span> <span class="nf">log_likelihood</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">signal</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="o">-</span><span class="n">noise</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span>

<span class="c"># The odds ratio between a template and a zero-signal</span>
<span class="k">def</span> <span class="nf">O</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
    <span class="n">zero_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">template</span><span class="p">))</span> 
    <span class="n">O</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">((</span><span class="n">data</span><span class="o">-</span><span class="n">zero_signal</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">data</span><span class="o">-</span><span class="n">template</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">O</span>
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Let's generate some noise and inject our signal</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">y_true</span><span class="p">))</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">+</span> <span class="n">y_true</span>
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># The odds of the true signal are of course much better than the odds of the zero-signal</span>
<span class="n">O</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>33.298957479806404
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># What if we look for the wrong signal, like the real signal in reverse?</span>
<span class="c"># The odds are still better than the zero-signal, but much worse than the real signal.</span>
<span class="c"># Remember, these numbers are on a logarithmic scale!</span>
<span class="n">O</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">y_true</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>24.078074844782517
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># If we take a completely nonsensical signal, such as expecting</span>
<span class="c"># a large constant offset, the odds are worse than for the</span>
<span class="c"># zero-signal.</span>
<span class="n">O</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">y_true</span><span class="p">)),</span> <span class="n">sigma</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>-54.193588383500007
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># The odds ratio of the zero-signal will of course yield 0 by definition.</span>
<span class="n">zero_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_true</span><span class="p">))</span>
<span class="n">O</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">zero_signal</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>0.0
</code></pre>
</div>

<h3 id="searching-the-parameter-space">Searching the parameter space</h3>

<p>So now let’s use our new mathematical machinery to search the parameter space for parameters with high likelihood. The simplest thing we can do is just do a grid search.</p>

<p>In our case, the <code class="highlighter-rouge">chirp</code> function is simple enough that we can just generate templates on the fly. Real gravitational waves templates, however, are computationally very costly to produce. In such a case, it may make more sense to generate a big template bank in advance and use that for your grid search.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Let's search for the maximum odds ratio we can find...</span>
<span class="n">Omax</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c"># ...and the associated parameters. We will just search in two dimensions:</span>
<span class="c"># the base amplitude and base the frequency.</span>
<span class="n">Amax</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fmax</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c"># Injection values for our parameters</span>
<span class="n">A_true</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">f_true</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c"># Defining our grid. Of course we're cheating a little by zooming</span>
<span class="c"># in on the true values.</span>
<span class="n">A_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">A_true</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">f_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">f_true</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="c"># And an array to store all the odds ratio values</span>
<span class="n">Ofun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">A_range</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">f_range</span><span class="p">)))</span>

<span class="c"># And then just loop over all possible parameter combinations</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_range</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_range</span><span class="p">)):</span>
        <span class="c"># Calculate the odds ratio</span>
        <span class="n">Ocur</span> <span class="o">=</span> <span class="n">O</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">chirp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tc_true</span><span class="p">,</span> <span class="n">offset_true</span><span class="p">,</span> <span class="n">A_range</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dA_true</span><span class="p">,</span> <span class="n">f_range</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">df_true</span><span class="p">),</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="n">Ofun</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ocur</span>
        
        <span class="c"># And keep track of the maximum</span>
        <span class="k">if</span> <span class="n">Ocur</span> <span class="o">&gt;</span> <span class="n">Omax</span><span class="p">:</span>
            <span class="n">Omax</span> <span class="o">=</span> <span class="n">Ocur</span>
            <span class="n">Amax</span> <span class="o">=</span> <span class="n">A_range</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">fmax</span> <span class="o">=</span> <span class="n">f_range</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

<span class="c"># Did we find the right values?</span>
<span class="k">print</span><span class="p">(</span><span class="n">A_true</span><span class="p">,</span> <span class="n">Amax</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f_true</span><span class="p">,</span> <span class="n">fmax</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">Omax</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>10 9.49494949495
0.1 0.10101010101
35.3795953551
</code></pre>
</div>

<p>We did not find the exact values of the parameters, but we’re pretty close.</p>

<p>Let’s visualize the odds ratios for our template bank. The blue dot represents the real parameter values, the red dot the ones we estimated to be the real ones.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Plot our log odds function</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Ofun</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">f_true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">A_true</span><span class="p">],</span> <span class="n">origin</span><span class="o">=</span><span class="s">'lower'</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">f_true</span><span class="o">/</span><span class="n">A_true</span><span class="p">,</span> \
          <span class="n">cmap</span><span class="o">=</span><span class="s">'copper'</span><span class="p">)</span>

<span class="c"># Add a colorbar for scale</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>

<span class="c"># Add the injected and recovered values</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">fmax</span><span class="p">],</span> <span class="p">[</span><span class="n">Amax</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">f_true</span><span class="p">],</span> <span class="p">[</span><span class="n">A_true</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s">'darkblue'</span><span class="p">)</span>

<span class="c"># Plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'f'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'A'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre>
</div>

<p><img src="/pages/MatchedFiltering_files/MatchedFiltering_25_0.png" alt="png" /></p>

<h3 id="exercise-2">Exercise 2</h3>
<p>It is interesting to have a look at how the odds ratio varies as you vary the parameters.</p>

<ol>
  <li>Does an incorrect choice of amplitude lead immediately to a very low odds ratio? Can you think of an explanation for this?</li>
  <li>The odds ratio seems to oscillate as you change the frequency; can you explain why?</li>
  <li>In the ranges we specified for the parameters, we can get to negative odds ratios by choosing the wrong frequency, but not by choosing the wrong amplitude. Are there any values for the amplitude that would lead to negative odds ratios?</li>
</ol>

<h2 id="concluding-remarks">Concluding remarks</h2>

<p>We’ve now seen how to do basic parameter estimation using matched filtering. Employing a grid search, we even got a sense of the probability distribution of the parameters.</p>

<p>In reality, there are of course generally more than two parameters to estimate, and we don’t have the luxury of knowing which part of the grid to zoom into. We could start with a wide grid and then iteratively narrow it down, but in reality recourse is generally taken to statistical methods. In the <a href="/pe-pymc/">second part of this session</a>, we’ll look at how to do parameter estimation using Monte Carlo techniques.</p>

    </div>
</div>

          <div class="row">
            <div class="col-md-12 col-xs-12 footer">
              <footer>
  © 2017 Marco Tompitak - Powered by Jekyll.
</footer>

            </div>
          </div>
        </div> <!-- end /.col-md-9 -->
      </div> <!-- end /.row -->
    </div>

    
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="https://code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<script src="/static/js/thickbox-compressed.js"></script>
<script src="/static/js/material.min.js"></script>
<script src="/static/js/main.js"></script>
<script src="/static/js/projects.js"></script>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47199852-2', 'auto');
  ga('send', 'pageview');

</script>
  </body>
</html>
