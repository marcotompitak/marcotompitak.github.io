<!DOCTYPE html>
<html>
  <head>
    
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="shortcut icon" href="/static/img/favicon.ico" />
        <title>Kaggle - Wikipedia - Marco Tompitak</title>
        <meta name="author" content="Marco Tompitak" />
        <meta name="description" content="Kaggle - Wikipedia" />
        <meta name="keywords" content="Kaggle - Wikipedia, Marco Tompitak, " />

        <meta content="0" property="fb:app_id">
        <meta content="Marco Tompitak" property="og:site_name">
        
          <meta content="Kaggle - Wikipedia" property="og:title">
        
        
          <meta content="article" property="og:type">
        
        
          <meta content="My GitHub Page" property="og:description">
        
        
          <meta content="http://localhost:4000/kaggle-wikipedia/" property="og:url">
        
        
        
          <meta content="http://localhost:4000/static/img/logo-high-resolution.png" property="og:image">
        
        
        
        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@\#">
        <meta name="twitter:creator" content="@\#">
        
          <meta name="twitter:title" content="Kaggle - Wikipedia">
        
        
          <meta name="twitter:url" content="http://localhost:4000/kaggle-wikipedia/">
        
        
          <meta name="twitter:description" content="My GitHub Page">
        
        

      <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">
      <script type="text/javascript">window.baseurl = 'http://localhost:4000';</script>
      
        <!-- Custom Fonts -->
        <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto:300,400,500,700" type="text/css">

        <!-- FontAwesome icons -->
        <link rel="stylesheet" href="https://use.fontawesome.com/74dfc6cf47.css">

        <!-- Core BootStrap CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <!-- Material Design CSS -->
        <link rel="stylesheet" href="/static/css/bootstrap-material-design.min.css">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/static/css/syntax.css">

        <!-- Custom CSS -->        
        <link rel="stylesheet" href="/static/css/thickbox.css">
        <link rel="stylesheet" href="/static/css/main.css">
        <link rel="stylesheet" href="/static/css/projects.css">

        <script type="text/javascript">
          //loadingImage is relative to project dir
          var tb_pathToImage = "/static/img/loadingAnimation.gif";
        </script>

  </head>

  <body class="home overflow-hidden">
    <div class="header-panel shadow-z-2">
      <div class="container">
        <div class="row">
          <div class="col-md-3 col-sm-4 col-xs-12">
            <div class="row-picture">
              <img id="about" class="logo-img" src="/static/img/avatar.svg" height="75px" width="75px">
            </div>
            <div class="row-details">
              <h4 class="list-group-item-heading">Marco Tompitak</h4>
              <p class="list-group-item-text">Biophysicist</p>
              <div class="social-icons">
	
        <a class="icon" target="_blank" href="https://github.com/marcotompitak"><i class="fa fa-github"></i></a>
    
        <a class="icon" target="_blank" href="https://www.linkedin.com/in/marcotompitak/"><i class="fa fa-linkedin"></i></a>
    
        <a class="icon" target="_blank" href="https://stackexchange.com/users/2808839/marco-tompitak"><i class="fa fa-stack-exchange"></i></a>
    
        <a class="icon" target="_blank" href="http://www.rapiddiffusion.com/"><i class="fa fa-pencil-square-o"></i></a>
    
</div>

            </div>
            <div class="navbar-header pull-right">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <i class="fa fa-2x fa-bars"></i>
              </button>
            </div>
          </div>
          <div class="col-md-9 col-sm-8 col-xs-12">
          <div class="row">
            <h2 class="blog-title-pro ">Kaggle - Wikipedia</h2>
            
            </div>
            <p class="info">
              
              
            </p>
          </div>
        </div>
      </div>
    </div>

    <div class="container main outer">
      <div class="row">
        <div class="col-md-3 col-xs-12">
              <nav class="menu">
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
    <ul class="list-separator nav navbar-nav well well-primary page">

	
	
	
	
	
	
    
	
	<li class="col-lg-12 col-md-12 col-sm-4 col-xs-12  kaggle-wikipedia"><a href="/" target="_self"><i class="fa fa-home"></i> Home</a></li>

	
	
	
	
	
	
    
	
	<li class="col-lg-12 col-md-12 col-sm-4 col-xs-12  kaggle-wikipedia"><a href="/about/" target="_self"><i class="fa fa-user"></i> About</a></li>

	
	
	
	
	
	
    
	
	<li class="col-lg-12 col-md-12 col-sm-4 col-xs-12  kaggle-wikipedia"><a href="/projects" target="_self"><i class="fa fa-desktop"></i> Projects</a></li>

	
	
	
	
	
	
    
	
	<li class="col-lg-12 col-md-12 col-sm-4 col-xs-12  kaggle-wikipedia"><a href="/publications" target="_self"><i class="fa fa-file-text-o"></i> Publications</a></li>

	
	
	
	
	
	
    
	
	<li class="col-lg-12 col-md-12 col-sm-4 col-xs-12  kaggle-wikipedia"><a href="https://github.com/marcotompitak" target="_self"><i class="fa fa-github"></i> Github</a></li>

</ul>

    </div>
    </nav>

        </div>
        <div class="col-md-9 col-xs-12 full">
          <div class="well" style="text-align:justify">
    
    <div>
    	<h2 id="kaggle-competition-wikipedia-traffic-time-series">Kaggle Competition: Wikipedia Traffic Time Series</h2>

<p>In this notebook we’ll have a look at the <a href="https://www.kaggle.com/c/web-traffic-time-series-forecasting">Wikipedia Traffic Kaggle competition</a>. The goal is to forecast the amount of traffic to various Wikipedia pages.</p>

<p>Let’s start by having a look at the data.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="kn">from</span> <span class="nn">fbprophet</span> <span class="kn">import</span> <span class="n">Prophet</span>
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Load in the training data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'input/train_1.csv'</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skiprows</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">11072</span><span class="p">),</span> <span class="n">nrows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<span class="c"># Gather the metadata</span>

<span class="c"># The metadata is in the column name of the transposed dataframe</span>
<span class="n">meta_string</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c"># The components are separated by underscores</span>
<span class="n">meta_split</span> <span class="o">=</span> <span class="n">meta_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'_'</span><span class="p">)</span>

<span class="c"># We'll store the metadata in a dictionary</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c"># The article names can also contain underscores, on which we</span>
<span class="c"># didn't actually want to split, so we have to check that we</span>
<span class="c"># really got four pieces of data</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta_split</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
    <span class="c"># If not, we need to reconstruct the article name from the</span>
    <span class="c"># split elements, all but the last three</span>
    <span class="n">article_name_split</span> <span class="o">=</span> <span class="n">meta_split</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">meta_split</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">'article_name'</span><span class="p">]</span> <span class="o">=</span> <span class="s">"_"</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">article_name_split</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c"># Otherwise, it's just the first element in the split</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">'article_name'</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_split</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c"># The other pieces of metadata we get by counting from the end</span>
<span class="c"># of the split</span>
<span class="n">metadata</span><span class="p">[</span><span class="s">'domain'</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_split</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">meta_split</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">metadata</span><span class="p">[</span><span class="s">'access'</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_split</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">meta_split</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">metadata</span><span class="p">[</span><span class="s">'agent'</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_split</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">meta_split</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

<span class="c"># Rename the column to "traffic" instead of the metadata string</span>
<span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">'traffic'</span><span class="p">]</span>

<span class="c"># Convert the index to a datetime</span>
<span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

<span class="c"># Visualize the data</span>
<span class="n">data</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">title</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">'domain'</span><span class="p">]</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">metadata</span><span class="p">[</span><span class="s">'article_name'</span><span class="p">])</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">'center left'</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">));</span>
</code></pre>
</div>

<p><img src="/pages/Wikipedia_files/Wikipedia_2_0.png" alt="png" /></p>

<p>Above, we’ve loaded up the time series for one specific page, extracted the metadata, prepared the data a little, and finally plotted the series. The traffic for this page is quite steady, perhaps slightly decreasing over time, with two large peaks. One is a month-long peak in May, the latter a short peak of a few days in August.</p>

<p>The question is what such peaks mean. Should we expect another peak in the summer of 2017, or was this a one-off event? Unfortunately we don’t have a long enough window of time to be sure. So what can we do?</p>

<h2 id="a-very-simply-model">A very simply model</h2>

<p>The competition requires us to forecast a fairly short period of time: the next two months after the period for which the data is provided. On that time scale, questions about trends on the scale of seasons and beyond may not be very relevant. Therefore, let’s try something simple: we just assume that the time series will continue as it has in the recent past. We’ll take the median value of the last month or so, and just use that single value as our forecast. Let’s split our data into a training and test set and see how it goes.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Training and test sets</span>
<span class="n">ntrain</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="n">data_train</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">ntrain</span><span class="p">]</span>
<span class="n">data_test</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ntrain</span><span class="p">:]</span>
</code></pre>
</div>

<p>To score our prediction, the competition uses <a href="https://en.wikipedia.org/wiki/Symmetric_mean_absolute_percentage_error">SMAPE</a>, so we’ll implement a function to calculate it, as well as some functions to make our predictions.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="s">"""
Implement the SMAPE score
"""</span>
<span class="k">def</span> <span class="nf">SMAPE</span><span class="p">(</span><span class="n">truth</span><span class="p">,</span> <span class="n">prediction</span><span class="p">):</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">truth</span> <span class="o">-</span> <span class="n">prediction</span><span class="p">)</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">truth</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">prediction</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">200</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numerator</span><span class="o">/</span><span class="n">denominator</span><span class="p">)</span>

<span class="s">"""
Calculate the median of a time series over a period at the end
of that series.
"""</span>
<span class="k">def</span> <span class="nf">past_median</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">days</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">series</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="n">days</span><span class="p">:]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="s">"""
Make a past-median-based prediction.
"""</span>
<span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">median_days</span><span class="p">):</span>
    <span class="n">train_median</span> <span class="o">=</span> <span class="n">past_median</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">median_days</span><span class="p">)</span>
    <span class="n">test_predict</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">test_predict</span><span class="p">[</span><span class="s">'traffic'</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_median</span>
    <span class="k">return</span> <span class="n">test_predict</span>
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Create a forecast based on our training set</span>
<span class="n">forecast</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">data_train</span><span class="p">,</span> <span class="n">predict</span><span class="p">(</span><span class="n">data_train</span><span class="p">,</span> <span class="n">data_test</span><span class="p">,</span> <span class="mi">50</span><span class="p">)])</span>

<span class="c"># Dataframe containing both the real data and our forecast for plotting</span>
<span class="n">combined</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">combined</span><span class="p">[</span><span class="s">'forecast'</span><span class="p">]</span>  <span class="o">=</span> <span class="n">forecast</span><span class="p">[</span><span class="s">'traffic'</span><span class="p">]</span>

<span class="n">combined</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>
</code></pre>
</div>

<p><img src="/pages/Wikipedia_files/Wikipedia_7_0.png" alt="png" /></p>

<p>Above we made a prediction using a 50-day median and plotted the result. The constant value of course doesn’t capture the variations in the data, but besides that it seems like a reasonable prediction. Our SMAPE score is not bad:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">SMAPE</span><span class="p">(</span><span class="n">predict</span><span class="p">(</span><span class="n">data_train</span><span class="p">,</span> <span class="n">data_test</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">data_test</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>13.852541979165048
</code></pre>
</div>

<p>Performing this same analysis on a random sample (see <code class="highlighter-rouge">forecast_median.py</code>) of 1200 pages from the data set (about 1% of the set), we find an average SMAPE score of 52.48, which is similar to the scores currently on the leaderboard. Can we do any better?</p>

<h2 id="a-more-elaborate-prophecy">A more elaborate Prophecy</h2>

<p>Let’s try something a little fancier. We’ll use <a href="https://facebookincubator.github.io/prophet/">Facebook’s Prophet</a> package to do our forecasting. It’s a package specifically designed for forecasting based on time series, and includes support for linear trends, capped growth and, through Fourier series, periodicity or seasonality. Can this approach help us out?</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Setting up a training dataframe for Prophet</span>
<span class="n">prophet_train</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_train</span><span class="p">)))</span>
<span class="n">prophet_train</span><span class="p">[</span><span class="s">'ds'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_train</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">prophet_train</span><span class="p">[</span><span class="s">'y'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_train</span><span class="p">[</span><span class="s">'traffic'</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

<span class="c"># Fitting the model. We'll use yearly seasonality for this set.</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Prophet</span><span class="p">(</span><span class="n">yearly_seasonality</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">prophet_train</span><span class="p">)</span>

<span class="c"># Generate prediction</span>
<span class="n">future</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">make_future_dataframe</span><span class="p">(</span><span class="n">periods</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="n">ntrain</span><span class="p">)</span>
<span class="n">forecast</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
<span class="n">forecast</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">forecast</span><span class="p">[</span><span class="s">'ds'</span><span class="p">]</span>
<span class="c"># Dataframe containing both the real data and our forecast for plotting</span>
<span class="n">combined</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">combined</span><span class="p">[</span><span class="s">'forecast'</span><span class="p">]</span>  <span class="o">=</span> <span class="n">forecast</span><span class="p">[</span><span class="s">'yhat'</span><span class="p">]</span>
<span class="n">combined</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>
</code></pre>
</div>

<p><img src="/pages/Wikipedia_files/Wikipedia_11_0.png" alt="png" /></p>

<p>Above, we fitted a Prophet model to our time series. As a fit, it does a decent job, recognizing some of the oscillatory behavior and peaks in the signal. However, as a forecast, for the last quarter of the series, it doesn’t look so good. It’s overshooting the true values, and we don’t find a great score:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">SMAPE</span><span class="p">(</span><span class="n">forecast</span><span class="p">[</span><span class="s">'yhat'</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="n">ntrain</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">data_test</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>39.148372106019352
</code></pre>
</div>

<p>What seems to be happening is that the model is overfitting the data for our purposes. If the big peak in summer is a real seasonal event, this fit is great: it will predict the same peak next year. However, if the features in the data are mostly random, or one-off events, fitting our model to them doesn’t help. At least for our current purpose of short-range forecasting, we’re not doing any better.</p>

<p>Perhaps we can improve the results by smoothing out the results a bit. Especially mitigating large outliers may help.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Set up a new dataframe</span>
<span class="n">prophet_train_filtered</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_train</span><span class="p">)))</span>
<span class="n">prophet_train_filtered</span><span class="p">[</span><span class="s">'ds'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_train</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c"># Apply a rolling median filter to the data</span>
<span class="n">prophet_train_filtered</span><span class="p">[</span><span class="s">'y'</span><span class="p">]</span> <span class="o">=</span> <span class="n">prophet_train</span><span class="p">[</span><span class="s">'y'</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">min_periods</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">center</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>

<span class="c"># Fit a model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Prophet</span><span class="p">(</span><span class="n">yearly_seasonality</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">prophet_train_filtered</span><span class="p">)</span>

<span class="c"># Predict</span>
<span class="n">future</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">make_future_dataframe</span><span class="p">(</span><span class="n">periods</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="n">ntrain</span><span class="p">)</span>
<span class="n">forecast_filtered</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
<span class="n">forecast_filtered</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">forecast_filtered</span><span class="p">[</span><span class="s">'ds'</span><span class="p">]</span>

<span class="c"># Dataframe containing both the real data and our forecast for plotting</span>
<span class="n">combined</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">combined</span><span class="p">[</span><span class="s">'forecast'</span><span class="p">]</span>  <span class="o">=</span> <span class="n">forecast_filtered</span><span class="p">[</span><span class="s">'yhat'</span><span class="p">]</span>
<span class="n">combined</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>
</code></pre>
</div>

<p><img src="/pages/Wikipedia_files/Wikipedia_15_0.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">SMAPE</span><span class="p">(</span><span class="n">forecast_filtered</span><span class="p">[</span><span class="s">'yhat'</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="n">ntrain</span><span class="p">:]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">data_test</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>37.389127378173001
</code></pre>
</div>

<p>The smoothing indeed improves the score, but not substantially. We are still not close to the score of our median result, which is essentially just a very aggressive smoothing.</p>

<p>We have only seen a single dataset, but unfortunately we do not fare better in general. Let’s consider the sample from before. For each dataset, filtering may or may not improve things, so we will try both. Additionally, we will turn the yearly seasonality on or off, since the forecasts may or may not benefit from including such long-term trends. Thus in total, we will fit four models to each dataset; see <code class="highlighter-rouge">forecast_seasonality_filtering.py</code> and the <code class="highlighter-rouge">bash</code> scripts that call it.</p>

<p>Choosing for every page the optimal of these four models, we still obtain a score of 64.48; hardly impressive.</p>

<h2 id="back-to-a-simple-model-just-slightly-less">Back to a simple model, just slightly less</h2>

<p>We see that Facebook’s Prophet package is not really helping us out here. The features it is fitting to do not seem to be very relevant. This is perhaps just because the periods of the seasonality that it considers are too long-term. We simply don’t have a big enough time window to properly fit yearly periodic fluctuations or events.</p>

<p>But that doesn’t mean that no periodicity exists. Perhaps looking at more short-term fluctuations would help. For now, let’s go for a simple proof of concept. We go back to our past-median model, but we add a slight bit of nuance: we separate weekdays from weekends. Many pages on Wikipedia probably get more traffic on weekends, when people have time to look stuff up. On the other hand, some pages may be useful to people at work, and receive more traffic during the week. Either way, what we can do is calculate our past mean separately for weekdays and weekends, and forecast accordingly.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Add a boolean it's-a-weekday column</span>
<span class="n">data</span><span class="p">[</span><span class="s">'weekday'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">weekday</span> <span class="o">&lt;</span> <span class="mi">5</span>

<span class="c"># Rebuild the training and test sets</span>
<span class="n">ntrain</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="n">data_train</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">ntrain</span><span class="p">]</span>
<span class="n">data_test</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ntrain</span><span class="p">:]</span>

<span class="c"># We now have additional information</span>
<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</code></pre>
</div>

<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>traffic</th>
      <th>weekday</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2015-07-01</th>
      <td>1287</td>
      <td>True</td>
    </tr>
    <tr>
      <th>2015-07-02</th>
      <td>1370</td>
      <td>True</td>
    </tr>
    <tr>
      <th>2015-07-03</th>
      <td>887</td>
      <td>True</td>
    </tr>
    <tr>
      <th>2015-07-04</th>
      <td>745</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2015-07-05</th>
      <td>925</td>
      <td>False</td>
    </tr>
  </tbody>
</table>
</div>

<p>We now have an additional feature that tells us whether a data point corresponds to a weekday or not. Let’s predict based on these two different groups.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="s">"""
Calculate the median over the past so many days, but only
taking into account the weekdays.
"""</span>
<span class="k">def</span> <span class="nf">past_median_weekday</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">days</span><span class="p">):</span>
    <span class="n">past_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="n">days</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">past_data</span><span class="p">[</span><span class="n">past_data</span><span class="p">[</span><span class="s">'weekday'</span><span class="p">]]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="s">"""
Calculate the median over the past so many days, but only
taking into account the weekends.
"""</span>
<span class="k">def</span> <span class="nf">past_median_weekend</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">days</span><span class="p">):</span>
    <span class="n">past_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="n">days</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">past_data</span><span class="p">[</span><span class="o">~</span><span class="n">past_data</span><span class="p">[</span><span class="s">'weekday'</span><span class="p">]]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="s">"""
Generate a prediction with separate values for weekdays
and weekends.
"""</span>
<span class="k">def</span> <span class="nf">predict_weekday_based</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">median_days</span><span class="p">):</span>
    <span class="n">weekday_median</span> <span class="o">=</span> <span class="n">past_median_weekday</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">median_days</span><span class="p">)</span>
    <span class="n">weekend_median</span> <span class="o">=</span> <span class="n">past_median_weekend</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">median_days</span><span class="p">)</span>
    <span class="n">test_predict</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">test_predict</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">test_predict</span><span class="p">[</span><span class="s">'weekday'</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="s">'traffic'</span><span class="p">]</span> <span class="o">=</span> <span class="n">weekday_median</span>
    <span class="n">test_predict</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">test_predict</span><span class="p">[</span><span class="s">'weekday'</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="s">'traffic'</span><span class="p">]</span> <span class="o">=</span> <span class="n">weekend_median</span>
    <span class="k">return</span> <span class="n">test_predict</span>


<span class="c"># Create a forecast based on our training set</span>
<span class="n">forecast</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">data_train</span><span class="p">,</span> <span class="n">predict_weekday_based</span><span class="p">(</span><span class="n">data_train</span><span class="p">,</span> <span class="n">data_test</span><span class="p">,</span> <span class="mi">50</span><span class="p">)])</span>

<span class="c"># Dataframe containing both the real data and our forecast for plotting</span>
<span class="n">combined</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">combined</span><span class="p">[</span><span class="s">'forecast'</span><span class="p">]</span>  <span class="o">=</span> <span class="n">forecast</span><span class="p">[</span><span class="s">'traffic'</span><span class="p">]</span>

<span class="n">combined</span><span class="p">[[</span><span class="s">'traffic'</span><span class="p">,</span> <span class="s">'forecast'</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">();</span>
</code></pre>
</div>

<p><img src="/pages/Wikipedia_files/Wikipedia_20_0.png" alt="png" /></p>

<p>The difference is not huge, but the weekend effect does seem to be real: our SMAPE score has improved. On the 1200-page sample, the average score is down slightly to 52.36.</p>

<p>This was finally the technique I used to generate a full submission. It scored 45.2 on the first-round test data, which, at time of writing, is about halfway up the leaderboard.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">SMAPE</span><span class="p">(</span><span class="n">predict_weekday_based</span><span class="p">(</span><span class="n">data_train</span><span class="p">,</span> <span class="n">data_test</span><span class="p">,</span> <span class="mi">50</span><span class="p">)[</span><span class="s">'traffic'</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">data_test</span><span class="p">[</span><span class="s">'traffic'</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>11.779228833580836
</code></pre>
</div>


    </div>
</div>

          <div class="row">
            <div class="col-md-12 col-xs-12 footer">
              <footer>
  © 2017 Marco Tompitak - Powered by Jekyll.
</footer>

            </div>
          </div>
        </div> <!-- end /.col-md-9 -->
      </div> <!-- end /.row -->
    </div>

    
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="https://code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<script src="/static/js/thickbox-compressed.js"></script>
<script src="/static/js/material.min.js"></script>
<script src="/static/js/main.js"></script>
<script src="/static/js/projects.js"></script>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47199852-2', 'auto');
  ga('send', 'pageview');

</script>
  </body>
</html>
